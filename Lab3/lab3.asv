clear all; 
 


% setup important vals 
T = 0.2764;
t_sim =20;
s = tf('s');
z = tf('z', T);

% Simulink defines 

G_D_Inner_Loop = (0.02379*z + 0.01572)/(z^2 - 1.285*z + 0.2846)

D_Inner_Loop = (3.896*z^5 + 0.5876*z^4 + 1.428*z^3 + 1.404*z^2 - 1.059*z + 0.1435)/...
    (z^6 + 0.1513*z^5 + 0.2745*z^4 + 0.1678*z^3 + 0.0828*z^2 + 0.01034*z - 0.007662)
                                                                          

% does the plant have a double integrator?
double_integrator_flag = 1;

% should the controller have an integrator?
controller_integrator_flag = 0;

%Define the cont. plant
G_C = -0.231035423/(s^2);

%Convert to cont. plant -> DT
G_D = c2d(G_C, T)
[r, p, k] = residue(G_D.Numerator{1}, G_D.Denominator{1});

r
p
k
%% Plant Poles and Coefficients in its Partial Fraction Decomposition

stableRealPlantPoles = [];
stableComplexPlantPoles = [];
unstablePlantPoles = [1];

if double_integrator_flag
    if unstablePlantPoles(end) ~= 1
        disp('The final unstable plant pole must be z=1!');
    elseif length(find(unstablePlantPoles == 1)) > 1
  disp('There should only be one pole at z=1 included in unstablePlantPoles!');
    end
end

stablePlantPoles = [stableRealPlantPoles stableComplexPlantPoles];
qs = [stablePlantPoles unstablePlantPoles];

% coefficents go in order of the poles
cs = [-0.035300807939028];

if double_integrator_flag
    % coefficients include both c_n for 1/(z-1) and c_(n+1) for 1/(z-1)^2 for
    %       the pole at z=1
    c_double_integrator = -0.070601615878056;
    cs = [cs c_double_integrator];
end

n = length(qs);
nhat = length(stablePlantPoles);
nreal = length(stableRealPlantPoles);
ncomplex = length(stableComplexPlantPoles);

% verify that your plant is correct!
z = tf('z',T);
G = 0;
for k=1:n
    G = G + cs(k)/(z-qs(k));
end
if double_integrator_flag
    G = G + c_double_integrator/(z-1)^2;
end
G

%% Poles Chosen in the Simple Pole Approximation of W[z]

j = sqrt(-1);
realWPoles = [];
complexWPoles = [
    % -0.0873776745030093-0.0372846080634645j,
    % -0.0873776745030093+0.0372846080634645j,
    % 0.0398145622783408-0.128315239276495j,
    % 0.0398145622783408+0.128315239276495j,
    % 0.162860021390549-0.0234864521090333j,
    % 0.162860021390549+0.0234864521090333j,
    % 0.131467705328583+0.137172309361755j,
    % 0.131467705328583-0.137172309361755j,
    % -0.0154240746879819+0.21186575447679j,
    % -0.0154240746879819-0.21186575447679j,
    % -0.171597318226308+0.157176208051789j,
    % -0.171597318226308-0.157176208051789j,
    % -0.251082414870835+0.0115161166471086j,
    % -0.251082414870835-0.0115161166471086j,
    % -0.221504567434189-0.152104328031101j,
    % -0.221504567434189+0.152104328031101j,
    % -0.100625156402291-0.266645041017107j,
    % -0.100625156402291+0.266645041017107j,
    % 0.0639193411870662-0.293537591838271j,
    % 0.0639193411870662+0.293537591838271j,
    % 0.217419674749345-0.228043164843608j,
    % 0.217419674749345+0.228043164843608j,
    % 0.315680214960588-0.09298387969125j,
    % 0.315680214960588+0.09298387969125j,
    % 0.334642919165009+0.0730692592867988j,
    % 0.334642919165009-0.0730692592867988j,
    % 0.272449737069342+0.228300549212757j,
    % 0.272449737069342-0.228300549212757j,
    % 0.145918447309115+0.337761464253838j,
    % 0.145918447309115-0.337761464253838j,
    % -0.0161314201186724+0.379657447292892j,
    % -0.0161314201186724-0.379657447292892j,
    % -0.180481097367376+0.347637129048478j,
    % -0.180481097367376-0.347637129048478j,
    % -0.316371601878677+0.249717859843303j,
    % -0.316371601878677-0.249717859843303j,
    % -0.40059304690652+0.104881889619471j,
    % -0.40059304690652-0.104881889619471j,
    % -0.420373208585382-0.0615334502821899j,
    % -0.420373208585382+0.0615334502821899j,
    % -0.374103320953077-0.222647041866447j,
    % -0.374103320953077+0.222647041866447j,
    % -0.270256242577872-0.354276111737287j,
    % -0.270256242577872+0.354276111737287j,
    % -0.125023779634703-0.43811420260687j,
    % -0.125023779634703+0.43811420260687j,
    % 0.0407498767652842-0.463615624783736j,
    % 0.0407498767652842+0.463615624783736j,
    % 0.204801382856469-0.428580673362762j,
    % 0.204801382856469+0.428580673362762j,
    % 0.346408415002991-0.338601845853083j,
    % 0.346408415002991+0.338601845853083j,
    % 0.448763654002589-0.205636044618264j,
    % 0.448763654002589+0.205636044618264j,
    % 0.500582180483701-0.0460160904704355j,
    % 0.500582180483701+0.0460160904704355j,
    % 0.496884075076119+0.121783479732471j,
    % 0.496884075076119-0.121783479732471j,
    % 0.438995073219822+0.279344457057453j,
    % 0.438995073219822-0.279344457057453j,
    % 0.333882688795507+0.410240600285592j,
    % 0.333882688795507-0.410240600285592j,
    % 0.192992118530531+0.501551634615119j,
    % 0.192992118530531-0.501551634615119j,
    % 0.0307673443085216+0.544865460938937j,
    % 0.0307673443085216-0.544865460938937j,
    % -0.136957975701223+0.536742501477034j,
    % -0.136957975701223-0.536742501477034j,
    % -0.294533062213633+0.478670320014788j,
    % -0.294533062213633-0.478670320014788j,
    % -0.427888812617747+0.376578230964795j,
    % -0.427888812617747-0.376578230964795j,
    % -0.525661886847435+0.240009542968597j,
    % -0.525661886847435-0.240009542968597j,
    % -0.579981609120148+0.0810637593651061j,
    % -0.579981609120148-0.0810637593651061j,
    % -0.586894288286116-0.0867761163980815j,
    % -0.586894288286116+0.0867761163980815j,
    % -0.546432496579912-0.249822990698302j,
    % -0.546432496579912+0.249822990698302j,
    % -0.462363823910589-0.395277996274492j,
    % -0.462363823910589+0.395277996274492j,
    % -0.341673658442813-0.512161215952852j,
    % -0.341673658442813+0.512161215952852j,
    % -0.193849371721068-0.592028226593418j,
    % -0.193849371721068+0.592028226593418j,
    % -0.0300392265467227-0.629442328468999j,
    % -0.0300392265467227+0.629442328468999j,
    % 0.137840870897643-0.622193614809875j,
    % 0.137840870897643+0.622193614809875j,
    % 0.297984947599341-0.57127486467043j,
    % 0.297984947599341+0.57127486467043j,
    % 0.439500237848394-0.480639720509245j,
    % 0.439500237848394+0.480639720509245j,
    % 0.553089380260617-0.35678023690071j,
    % 0.553089380260617+0.35678023690071j,
    % 0.631578084164973-0.208168498103105j,
    % 0.631578084164973+0.208168498103105j,
    % 0.670268515720352-0.0446107255493169j,
    % 0.670268515720352+0.0446107255493169j,
    0.66711181893809+0.123437518741721j,
    0.66711181893809-0.123437518741721j,
    % 0.622705078023759+0.285549270360519j,
    % 0.622705078023759-0.285549270360519j,
    % 0.540128108171704+0.431956741772664j,
    % 0.540128108171704-0.431956741772664j,
    % 0.424643389206283+0.554101066596521j,
    % 0.424643389206283-0.554101066596521j,
    % 0.283288067138334+0.645075864543874j,
    % 0.283288067138334-0.645075864543874j,
    % 0.124390237705628+0.699947904321127j,
    % 0.124390237705628-0.699947904321127j,
    % -0.0429571803418972+0.715946702385781j,
    % -0.0429571803418972-0.715946702385781j,
    % -0.209432547189081+0.692522929712723j,
    % -0.209432547189081-0.692522929712723j,
    % -0.366001681154399+0.63128263827873j,
    % -0.366001681154399-0.63128263827873j,
    % -0.504388071091764+0.535810296411267j,
    % -0.504388071091764-0.535810296411267j,
    % -0.617475881493189+0.4113982690462j,
    % -0.617475881493189-0.4113982690462j,
    % -0.699629897893391+0.264703619117087j,
    % -0.699629897893391-0.264703619117087j,
    % -0.746922188206407+0.103354945527307j,
    % -0.746922188206407-0.103354945527307j,
    % -0.757260813525841-0.0644675135101512j,
    % -0.757260813525841+0.0644675135101512j,
    % -0.730421144342116-0.230455965203666j,
    % -0.730421144342116+0.230455965203666j,
    % -0.667985010735145-0.386582494990613j,
    % -0.667985010735145+0.386582494990613j,
    % -0.573196877444198-0.525471540321853j,
    % -0.573196877444198+0.525471540321853j,
    % -0.450749380133299-0.640722245836249j,
    % -0.450749380133299+0.640722245836249j,
    % -0.306512832190788-0.727169088797359j,
    % -0.306512832190788+0.727169088797359j,
    % -0.147224703223169-0.781072907455411j,
    % -0.147224703223169+0.781072907455411j,
    % 0.0198443870567967-0.800238214722554j,
    % 0.0198443870567967+0.800238214722554j,
    % 0.187231856826266-0.784056268254638j,
    % 0.187231856826266+0.784056268254638j,
    % 0.347616161547583-0.733476655545986j,
    % 0.347616161547583+0.733476655545986j,
    % 0.494127746448281-0.650913028130443j,
    % 0.494127746448281+0.650913028130443j,
    % 0.620626062679309-0.540091001890587j,
    % 0.620626062679309+0.540091001890587j,
    % 0.721933054996305-0.405848080078866j,
    % 0.721933054996305+0.405848080078866j,
    % 0.794016026786305-0.253896729412746j,
    % 0.794016026786305+0.253896729412746j,
    % 0.834115365245589-0.0905624506140248j,
    % 0.834115365245589+0.0905624506140248j,
    % 0.840815153876223+0.077491141507299j,
    % 0.840815153876223-0.077491141507299j,
    % 0.814057112907694+0.243538532730221j,
    % 0.814057112907694-0.243538532730221j,
    % 0.755100508074783+0.40105887685626j,
    % 0.755100508074783-0.40105887685626j,
    % 0.666432588693241+0.543983092317791j,
    % 0.666432588693241-0.543983092317791j,
    % 0.55163570901356+0.666913071202767j,
    % 0.55163570901356-0.666913071202767j,
    % 0.415218521600955+0.765306199713237j,
    % 0.415218521600955-0.765306199713237j,
    % 0.26241949373498+0.83562013457544j,
    % 0.26241949373498-0.83562013457544j,
    % 0.0989914885163239+0.875414579043165j,
    % 0.0989914885163239-0.875414579043165j,
    % -0.0690237140135978+0.883408584350282j,
    % -0.0690237140135978-0.883408584350282j,
    % -0.235522277913136+0.859493604750267j,
    % -0.235522277913136-0.859493604750267j,
    % -0.394558369979556+0.804704102561355j,
    % -0.394558369979556-0.804704102561355j,
    % -0.540549978082509+0.72114888975509j,
    % -0.540549978082509-0.72114888975509j,
    % -0.668464004088042+0.6119075708296j,
    % -0.668464004088042-0.6119075708296j,
    % -0.773975255252584+0.48089739472854j,
    % -0.773975255252584-0.48089739472854j,
    % -0.853595172449399+0.332716518332169j,
    % -0.853595172449399-0.332716518332169j,
    % -0.904767403957011+0.172470127085507j,
    % -0.904767403957011-0.172470127085507j,
    % -0.925928612793958+0.00558605490995794j,
    % -0.925928612793958-0.00558605490995794j,
    % -0.916534150646132-0.162373491369045j,
    % -0.916534150646132+0.162373491369045j,
    % -0.877049404159517-0.325897748785467j,
    % -0.877049404159517+0.325897748785467j,
    % -0.808908687313646-0.479704842156627j,
    % -0.808908687313646+0.479704842156627j,
    % -0.714444490481837-0.61890554208227j,
    % -0.714444490481837+0.61890554208227j,
    % -0.596790682779605-0.739148754275791j,
    % -0.596790682779605+0.739148754275791j
];


% ps = [realWPoles complexWPoles];
ps = generate_poles(200, 0.95, 0);  % Your generated poles

fprintf('complexWPoles = [\n');
for k = 1:length(ps)
    pole = ps(k);
    if imag(pole) == 0
        % Real pole
        fprintf('    %.15g', real(pole));
    else
        % Complex pole
        fprintf('    %.15g%+.15gj', real(pole), imag(pole));
    end
    
    % Print comma after each pole except the last
    if k < length(ps)
        fprintf(',\n');
    else
        fprintf('\n');
    end
end
fprintf('];\n');


mreal = sum(imag(ps) == 0);     % number of purely real poles
mcomplex = sum(imag(ps) > 0)*2; % count each conjugate pair twice
m = length(ps);

%% Calculation of alpha, beta, gamma, and gamma hat

alpha = zeros(m);

for i=1:m
    for k=1:n
        alpha(i,i) = alpha(i,i) + cs(k)/(ps(i)-qs(k));
    end
    if double_integrator_flag
        alpha(i,i) = alpha(i,i) + cs(n+1)/((ps(i)-1)^2);
    end
end

beta = zeros(n,m);
if double_integrator_flag
    beta = zeros(n+1,m);
end

for i=1:m
    for k=1:n
        beta(k,i) = cs(k)/(qs(k)-ps(i));
    end
    if double_integrator_flag
        beta(n,i) = beta(n,i) - cs(n+1)/((1-ps(i))^2);
        beta(n+1,i) = cs(n+1)/(1-ps(i));
    end
end

gamma = zeros(n-nhat,m);
if double_integrator_flag
    gamma = zeros(n+1-nhat,m);
end

for i=1:m
    for j=(nhat+1):n
        gamma(j-nhat,i) = cs(j)/(qs(j)-ps(i));
    end
    if double_integrator_flag
        gamma(n-nhat,i) = gamma(n-nhat,i) - cs(n+1)/((1-ps(i))^2);
        gamma(n+1-nhat,i) = cs(n+1)/(1-ps(i));
    end
end

gammaHat = zeros(n-nhat,nhat);
if double_integrator_flag
    gammaHat = zeros(n+1-nhat,nhat);
end

for k=1:nhat
    for j=(nhat+1):n
        gammaHat(j-nhat,k) = cs(j)/(qs(j)-qs(k));
    end
    if double_integrator_flag
        gammaHat(n-nhat,k) = gammaHat(n-nhat,k) - cs(n+1)/((1-qs(k))^2);
        gammaHat(n+1-nhat,k) = cs(n+1)/(1-qs(k));
    end
end

% verify on a simple example that alpha, beta, gamma, and gammahat are correct!
% alpha
% beta
% gamma
% gammaHat

%% Determination of A and b matrices for IOP equations

A = [alpha eye(m) zeros(m,nhat);
     beta [zeros(nhat,m) eye(nhat);
           zeros(size(beta,1)-nhat,m+nhat)];
     zeros(size(gamma)) gamma gammaHat];

b = [zeros(m+size(beta,1),1);
     -cs((nhat+1):end)'];

%% Determination of step response matrices

% time horizon
K = 100;

step_ry = zeros(K,m+nhat);

for k=1:K
    for i=1:m
        step_ry(k,i) = -(1-ps(i)^k)/(1-ps(i));
    end
    for j=1:nhat
        step_ry(k,m+j) = -(1-qs(j)^k)/(1-qs(j));
    end
end

step_ru = zeros(K,m);

for k=1:K
    for i=1:m
        step_ru(k,i) = (1-ps(i)^k)/(1-ps(i));
    end
end

% verify on a simple example that step_ry and step_ru are correct!
% step_ry
% step_ru

%% Determination of steady state vector

steadyState = zeros(1,m+nhat);
if controller_integrator_flag
    steadyState = zeros(3,m+nhat);
end

for i=1:m
    if ~controller_integrator_flag    
        steadyState(i) = 1/(1-ps(i));
    else
        steadyState(1,i) = 1/(1-ps(i));
        steadyState(2,i) = 1/(1-ps(i))^2;
        steadyState(3,i) = 1/(1-ps(i))^3;
    end
end

for k=1:nhat
    if ~controller_integrator_flag
        steadyState(m+k) = 1/(1-qs(k));
    else
        steadyState(1,m+k) = 1/(1-qs(k));
        steadyState(2,m+k) = 1/(1-qs(k))^2;
        steadyState(3,m+k) = 1/(1-qs(k))^3;
    end
end

% verify on a simple example that steadyState is correct!
%steadyState

%% Defining the variables for the optimization

wreal = sdpvar(mreal,1,'full');
wcomplex = sdpvar(mcomplex/2,1,'full','complex');
w = wreal;
for i=1:(mcomplex/2)
    w = [w;
         wcomplex(i);
         conj(wcomplex(i))];
end

xreal = sdpvar(mreal,1,'full');
xcomplex = sdpvar(mcomplex/2,1,'full','complex');
x = xreal;
for i=1:(mcomplex/2)
    x = [x;
         xcomplex(i);
         conj(xcomplex(i))];
end

xhatreal = sdpvar(nreal,1,'full');
xhatcomplex = sdpvar(ncomplex/2,1,'full','complex');
xhat = xhatreal;
for i=1:(ncomplex/2)
    xhat = [xhat;
            xhatcomplex(i);
            conj(xhatcomplex(i))];
end


% %% Define the step change
yref_initial = 0.10;
yref_final = 0.25;
step_magnitude = yref_final - yref_initial;
% 
% %% Scale the step response matrices FIRST
step_ru = step_ru * step_magnitude;
step_ry = step_ry * step_magnitude;
steadyState = steadyState * step_magnitude; 

%% Define constraints (using the scaled matrices)
% IOP constraint

Objective = 0;

% IOP constraint
Constraints = [A * [w; x; xhat] == b];

% Input saturation constraint
Constraints = [Constraints,
               max(step_ru*w) <= 0.7,
               min(step_ru*w) >= -0.7];

% Steady state constraint
if ~controller_integrator_flag
    Constraints = [Constraints,
                   0.15 + steadyState*[x; xhat] == 0];
else
    Constraints = [Constraints, 
        steadyState*[x; xhat] + [0.15; 0; 0] == [0; 0; 0]];
end

y_ss = (-steadyState(1,:)*[x;xhat]); 
jhat = 7/T; 

% Overshoot constraint
Constraints = [Constraints,
               max(step_ry * [x; xhat]) <= (1.45)*y_ss];

% Settling time constraint
Constraints = [Constraints,
               max(step_ry(jhat:end,:) * [x; xhat]) <= 1.02 * y_ss,
               min(step_ry(jhat:end,:) * [x; xhat]) >= 0.98 * y_ss];

%% Solving the optimization problem

% set some options for YALMIP and solver
options = sdpsettings('verbose',1,'solver','mosek');

% solve the problem
sol = optimize(Constraints,Objective,options);

% obtain the solution
wsol = value(w);
xsol = value(x);
xhatsol = value(xhat);

%% Plotting the solution

figure(1)
plot(T*(1:K),step_ry*[xsol;xhatsol]);
xlabel('Time [s]');
ylabel('y[k]');

figure(2)
plot(T*(1:K),step_ru*wsol);
xlabel('Time [s]');
ylabel('u[k]');

% use log scale for heat map?
log_scale_flag = 1;

% heat map
figure(3)
t = linspace(0,2*pi);
plot(cos(t),sin(t),'k--');
hold on;
if log_scale_flag
    scatter(real(ps),imag(ps),50,log(abs(wsol)),'filled');
    scatter(real(qs(1:nhat)),imag(qs(1:nhat)),50,log(abs(xhatsol)),'filled');
else
    scatter(real(ps),imag(ps),50,abs(wsol),'filled');
    scatter(real(qs(1:nhat)),imag(qs(1:nhat)),50,abs(xhatsol),'filled');
end
hold off;
colormap(jet);
colorbar;

%% Recover the transfer functions

z = tf('z',T);

% calculate W
W = 0;
for i=1:m
    W = W + wsol(i)/(z-ps(i));
end

% calculate X
X = 1;
for i=1:m
    X = X + xsol(i)/(z-ps(i));
end
for k=1:nhat
    X = X + xhatsol(k)/(z-qs(k));
end

% remove the imaginary coefficients in W
[num,den] = tfdata(W);
num{1} = real(num{1});
den{1} = real(den{1});
W = tf(num,den,T);

% remove the imaginary coefficients in X
[num,den] = tfdata(X);
num{1} = real(num{1});
den{1} = real(den{1});
X = tf(num,den,T);

% find the poles and zeros of W and X (if desired)
%zpk(W)
%zero(W)
%pole(W)
%zpk(X)
%zero(X)
%pole(X)


%% Verify design in DT

% compute D by hand
% j = sqrt(-1);
% D = (0.15246*(z-0.8423)*(z-0.8))/((z+0.4903)*(z-0.7796)*(z-0.3107));
% 
% % compute T_ry and T_ru by hand  (using Nf, Dg, etc)
% T_ry = (0.15246*(z-0.8423)*(z-0.8)*5*(z-0.7672)*(z-0.3128))/...
%        (0.15246*(z-0.8423)*(z-0.8)*5*(z-0.7672)*(z-0.3128) + ...
%         (z+0.4903)*(z-0.7796)*(z-0.3107)*(z-1)^2*(z-0.8));
% T_ru = (0.15246*(z-0.8423)*(z-0.8)*(z-1)^2*(z-0.8))/...
%        (0.15246*(z-0.8423)*(z-0.8)*5*(z-0.7672)*(z-0.3128) + ...
%         (z+0.4903)*(z-0.7796)*(z-0.3107)*(z-1)^2*(z-0.8));
% 
% figure(1)
% hold on;
% step(T_ry,'g');
% hold off;
% 
% figure(2)
% hold on;
% step(T_ru,'g');
% hold off;

%% Print numerator and denominator in space-delimited format

%% Calculate D = W/X
D = W/X;

% Get numerator and denominator
[num_D, den_D] = tfdata(D, 'v');

% Print in space-delimited format
fprintf('Numerator: [');
fprintf('%.15g, ', num_D);
fprintf(']\n');
fprintf('Denominator: [');
fprintf('%.15g, ', den_D);
fprintf(']\n');
